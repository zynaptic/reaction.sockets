/*
 * Zynaptic Reaction Sockets - An asynchronous programming framework for Java.
 * 
 * Copyright (c) 2016-2019, Zynaptic Limited.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 * 
 * Please visit www.zynaptic.com or contact reaction@zynaptic.com if you need
 * additional information or have any questions.
 */

package com.zynaptic.reaction.sockets.test.core;

import java.nio.ByteBuffer;
import java.util.Random;
import java.util.logging.Level;

import com.zynaptic.reaction.Deferrable;
import com.zynaptic.reaction.Deferred;
import com.zynaptic.reaction.Logger;
import com.zynaptic.reaction.Reactor;
import com.zynaptic.reaction.sockets.SocketClosedException;
import com.zynaptic.reaction.sockets.SocketHandle;
import com.zynaptic.reaction.sockets.SocketService;

/**
 * Implements a data sink for socket tests. The data sink may check against a
 * simple counting sequence or a pseudo-random sequence generated by the
 * standard Java {@link Random} library class.
 * 
 * @author Chris Holgate
 */
public class SocketTestDataSink implements Deferrable<ByteBuffer, Void> {
  private final Reactor reactor;
  private final Logger logger;
  private final SocketService socketService;
  private final SocketHandle socketHandle;
  private final Random dataReference;
  private final Random random;
  private final int minBufferSize;
  private final int maxBufferSize;
  private int dataCounter;
  private Exception fatalError;

  /**
   * Provides the public constructor for the data sink.
   * 
   * @param reactor This is the reactor service which is to be used for
   *   asynchronous event management.
   * @param logger This is the log service which is to be used for message
   *   logging.
   * @param socketService This is the socket service which is to be used for
   *   buffer management.
   * @param socketHandle This is the socket handle which is to be used for
   *   receiving the sink data.
   * @param dataSeed This is the seed for the random number generator that will be
   *   used to generate the pseudo-random data sequence. A null reference may be
   *   passed in order to use a simple counting sequence instead.
   * @param randomSeed This is the seed for the random number generator that will
   *   be used for selecting buffer sizes and receive request intervals. A null
   *   reference may be passed in order to use the default seed for the random
   *   number generator.
   * @param minBufferSize This is the minimum size of data buffers which will be
   *   generated by the test data source.
   * @param maxBufferSize This is the maximum size of data buffers which will be
   *   generated by the test data source.
   */
  public SocketTestDataSink(Reactor reactor, Logger logger, SocketService socketService, SocketHandle socketHandle,
      Long dataSeed, Long randomSeed, int minBufferSize, int maxBufferSize) {
    this.reactor = reactor;
    this.logger = logger;
    this.socketService = socketService;
    this.socketHandle = socketHandle;
    if (dataSeed == null) {
      this.dataReference = null;
    } else {
      this.dataReference = new Random(dataSeed);
    }
    if (randomSeed == null) {
      this.random = new Random();
    } else {
      this.random = new Random(randomSeed);
    }
    this.minBufferSize = minBufferSize;
    this.maxBufferSize = maxBufferSize;
    this.dataCounter = 0;
    this.fatalError = null;
  }

  /**
   * Provides the call point for starting the data checking process. This should
   * be called exactly once for each data sink instance.
   */
  public synchronized void consumeData() {
    int bufferSize = minBufferSize + random.nextInt(maxBufferSize - minBufferSize);
    socketHandle.read(bufferSize).addDeferrable(this, true);
  }

  /**
   * Accesses a fatal error exception if one was encountered. Returns a null
   * reference if no fatal errors occurred.
   * 
   * @return Returns a fatal error exception if present.
   */
  public Exception getFatalError() {
    return fatalError;
  }

  /*
   * Fill a new reference byte array with pseudo-random data and check it against
   * the received data.
   */
  private void checkDataBytes(byte[] source) {
    if (fatalError == null) {
      byte[] target = new byte[source.length];
      if (dataReference != null) {
        for (int i = 0; i < target.length; i++) {
          target[i] = (byte) (dataReference.nextInt());
        }
        dataCounter += target.length;
      } else {
        for (int i = 0; i < target.length; i++) {
          target[i] = (byte) (dataCounter++);
        }
      }

      // Log the reference data against the received data.
      if (logger.getLogLevel() == Level.FINEST) {
        StringBuilder stringBuilder = new StringBuilder("Reference : [ ");
        for (int i = 0; i < source.length; i++) {
          stringBuilder.append(target[i] + " ");
        }
        stringBuilder.append(']');
        logger.log(Level.FINEST, stringBuilder.toString());
        stringBuilder = new StringBuilder("Received  : [ ");
        for (int i = 0; i < source.length; i++) {
          stringBuilder.append(source[i] + " ");
        }
        stringBuilder.append(']');
        logger.log(Level.FINEST, stringBuilder.toString());
      }

      // Check the reference data against the received data.
      for (int i = 0; i < source.length; i++) {
        if (source[i] != target[i]) {
          logger.log(Level.SEVERE, "Data mismatch - registering fatal error");
          fatalError = new Exception("Data mismatch detected for <" + socketHandle.getSocketId() + ">");
          break;
        }
      }
    }
  }

  /*
   * On callback from receiving a previous block of data, perform data checking
   * before requesting the next data. Tests both forms of the socket read method.
   */
  public synchronized Void onCallback(Deferred<ByteBuffer> deferred, ByteBuffer dataBuffer) {
    int maxReadSize = minBufferSize + random.nextInt(maxBufferSize - minBufferSize);
    int readSize = (maxReadSize < dataBuffer.remaining()) ? maxReadSize : dataBuffer.remaining();
    byte[] readData = new byte[readSize];
    dataBuffer.get(readData);
    checkDataBytes(readData);

    // Tests the situation where data is being appended to a partially filled
    // buffer.
    if (dataBuffer.hasRemaining()) {
      socketHandle.read(dataBuffer).addDeferrable(this, true);
    }

    // Tests the situation where all the buffer data has been consumed and a read is
    // initiated with a new buffer.
    else {
      socketService.releaseByteBuffer(dataBuffer);
      reactor.runLater(x -> consumeData(), 50 + random.nextInt(100), null);
    }
    return null;
  }

  /*
   * Halt processing if the socket is closed and set the fatal error indicator on
   * other exceptions.
   */
  public synchronized Void onErrback(Deferred<ByteBuffer> deferred, Exception error) {
    if (error instanceof SocketClosedException) {
      logger.log(Level.INFO, "Halting test data checking on socket closed for <" + socketHandle.getSocketId() + ">",
          error);
    } else {
      logger.log(Level.SEVERE, "Test data sink fatal error for <" + socketHandle.getSocketId() + ">", error);
      fatalError = error;
    }
    return null;
  }
}
